From 568a557e9c96e07446c1447cfb460bbb69e37741 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 19 Aug 2018 00:14:00 -0400
Subject: [PATCH] Persistent and Temporary Meta API

Allows plugins to store metadata on many objects. Persistent data will
be saved with the object and survives restarts.

Temporary Metadata is a replacement API for Bukkit's Metadatable interface,
that provides an API that doesn't suck, and is simpler (ultimately just a hashmap)

diff --git a/src/main/java/com/destroystokyo/paper/meta/PaperMetaAccessor.java b/src/main/java/com/destroystokyo/paper/meta/PaperMetaAccessor.java
new file mode 100644
index 0000000000..88706a14c5
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/PaperMetaAccessor.java
@@ -0,0 +1,10 @@
+package com.destroystokyo.paper.meta;
+
+public class PaperMetaAccessor {
+    public static void setValue(PersistentMetaMap map, PersistentMetaKey key, Object value) {
+        map.putObject0(key, value);
+    }
+    public static <T> PersistentMetaList<T> newList() {
+        return new PersistentMetaList<>();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 8b80830933..3ab2a34454 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -14,7 +14,6 @@ import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortList;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
 import java.util.BitSet;
-import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
@@ -23,14 +22,12 @@ import java.util.Set;
 import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Function;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
-import org.bukkit.Server; // CraftBukkit
 import org.bukkit.craftbukkit.util.CraftMagicNumbers; // Paper
 
 public class Chunk implements IChunkAccess {
@@ -175,6 +172,7 @@ public class Chunk implements IChunkAccess {
     }
 
     public org.bukkit.Chunk bukkitChunk;
+    public PaperMetaApi.ChunkMetaHolder meta = new PaperMetaApi.ChunkMetaHolder(); // Paper
     public boolean mustSave;
     public boolean newChunk;
     // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 4d3ec96b93..239b7eab06 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -52,6 +52,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
     // CraftBukkit start
     private static final int CURRENT_LEVEL = 2;
     // Paper start
+    public PaperMetaApi.PersistentMetaHolder meta = new PaperMetaApi.PersistentMetaHolder(); // Paper
     public static Random SHARED_RANDOM = new Random() {
         private boolean locked = false;
         @Override
diff --git a/src/main/java/net/minecraft/server/NBTBase.java b/src/main/java/net/minecraft/server/NBTBase.java
index e21e60b003..b5e25093ed 100644
--- a/src/main/java/net/minecraft/server/NBTBase.java
+++ b/src/main/java/net/minecraft/server/NBTBase.java
@@ -117,6 +117,7 @@ public interface NBTBase {
 
     NBTBase clone();
 
+    default String getStringValue() { return b_(); } // Paper - OBFHELPER
     default String b_() {
         return this.toString();
     }
diff --git a/src/main/java/net/minecraft/server/PaperMetaApi.java b/src/main/java/net/minecraft/server/PaperMetaApi.java
new file mode 100644
index 0000000000..dad5a3c986
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PaperMetaApi.java
@@ -0,0 +1,463 @@
+package net.minecraft.server;
+
+import com.destroystokyo.paper.meta.MetaContainer;
+import com.destroystokyo.paper.meta.MetaMap;
+import com.destroystokyo.paper.meta.PaperMetaAccessor;
+import com.destroystokyo.paper.meta.PersistentMetaContainer;
+import com.destroystokyo.paper.meta.PersistentMetaKey;
+import com.destroystokyo.paper.meta.PersistentMetaList;
+import com.destroystokyo.paper.meta.PersistentMetaMap;
+import com.destroystokyo.paper.meta.TempMetaKey;
+import com.destroystokyo.paper.meta.TempMetaMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.Player;
+import org.bukkit.util.Vector;
+
+import java.util.Map.Entry;
+import java.util.regex.Pattern;
+
+public final class PaperMetaApi {
+
+    private static final String META_MAP = "MetaMap";
+    private static final String META_TYPE = "MetaType";
+    private static final String ITEM = "Item";
+    private static final String ENTITY_META = "_EntityMeta";
+    private static final String TILEENTITY_META = "_TileEntityMeta";
+    private static final String WORLD_META = "_WorldMeta";
+    private static final String CHUNK_META_LIST = "_ChunkMetaList";
+    private static final String BLOCK_POS = "_BlockPos";
+    private static final String CHUNK_META = "_ChunkMeta";
+
+    private PaperMetaApi() {}
+
+    public static PersistentMetaMap getTileEntityMetaMap(org.bukkit.block.BlockState block, boolean isWrite) {
+        final CraftBlockState craftBlock = (CraftBlockState) block;
+        final TileEntity tileEntity = ((CraftWorld) craftBlock.getWorld()).getHandle().getTileEntity(MCUtil.toBlockPosition(craftBlock.getLocation()));
+        if (tileEntity == null) {
+            return null;
+        }
+        if (tileEntity.metaMap == null && isWrite) {
+            tileEntity.metaMap = new PersistentMetaMap();
+        }
+        return tileEntity.metaMap;
+    }
+
+    /**
+     * Util for getting a MetaMap by location
+     * @param loc
+     * @return
+     */
+    public static PersistentMetaMap getBlockMetaMap(org.bukkit.Location loc, boolean isWrite) {
+        return getBlockMetaMap(((CraftChunk) loc.getChunk()).getHandle(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), isWrite);
+    }
+
+    /**
+     * Util for getting a MetaMap for a chunk
+     * @param chunk
+     * @return
+     */
+    public static PersistentMetaMap getChunkMetaMap(org.bukkit.Chunk chunk, boolean isWrite) {
+        return getBlockMetaMap(((CraftChunk) chunk).getHandle(), 0, -1, 0, isWrite);
+    }
+
+    static void loadEntityMeta(Entity entity, NBTTagCompound nbt) {
+        if (nbt.hasKey(ENTITY_META)) {
+            entity.metaMap = getMetaMapFromCompound(nbt.getCompound(ENTITY_META));
+        }
+    }
+
+    static void saveEntityMeta(Entity entity, NBTTagCompound nbt) {
+        if (entity.metaMap != null && !entity.metaMap.isEmpty()) {
+            nbt.set(ENTITY_META, getNbtFromObject(entity.metaMap));
+        }
+    }
+
+    static void loadTileEntityMeta(TileEntity tileEntity, NBTTagCompound nbt) {
+        if (nbt.hasKey(TILEENTITY_META)) {
+            tileEntity.metaMap = getMetaMapFromCompound(nbt.getCompound(TILEENTITY_META));
+        }
+    }
+
+    static void saveTileEntityMeta(TileEntity tileEntity, NBTTagCompound nbt) {
+        if (tileEntity.metaMap != null && !tileEntity.metaMap.isEmpty()) {
+            nbt.set(TILEENTITY_META, getNbtFromObject(tileEntity.metaMap));
+        }
+    }
+
+    static void loadWorldMeta(WorldData world, NBTTagCompound nbt) {
+        if (nbt.hasKey(WORLD_META)) {
+            NBTTagCompound nbtmeta = nbt.getCompound(WORLD_META);
+            world.metaMap = getMetaMapFromCompound(nbtmeta);
+        }
+        if (world.metaMap == null) {
+            world.metaMap = new PersistentMetaMap();
+        }
+    }
+
+    static void saveWorldMeta(WorldData world, NBTTagCompound nbt) {
+        if (world.metaMap != null && !world.metaMap.isEmpty()) {
+            NBTBase nbtmeta = getNbtFromObject(world.metaMap);
+            nbt.set(WORLD_META, nbtmeta);
+        }
+    }
+
+    /**
+     * Saves this chunks Meta Data into NBT
+     * @param cmp
+     * @param chunk
+     */
+    static void saveChunkMetaNbt(NBTTagCompound cmp, Long2ObjectMap<PersistentMetaMap> metaMap) {
+        if (metaMap == null || metaMap.isEmpty()) {
+            return;
+        }
+        NBTTagList meta = new NBTTagList();
+        for (Entry<Long, PersistentMetaMap> entry : metaMap.entrySet()) {
+            PersistentMetaMap list = entry.getValue();
+            if (!list.isEmpty()) {
+                NBTTagCompound pos = serializePos(entry.getKey());
+                NBTTagCompound metacmp = getCompoundFromMetaMap(list);
+                metacmp.set(BLOCK_POS, pos);
+                meta.add(metacmp);
+            }
+        }
+
+        if (!meta.isEmpty()) {
+            cmp.set(CHUNK_META_LIST, meta);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from NBT
+     * @param cmp
+     * @param chunk
+     */
+    static void loadChunkMetaNbt(NBTTagCompound cmp, Chunk chunk) {
+        ChunkPersistentMeta meta = chunk.meta;
+        if (cmp.hasKey(CHUNK_META)) {
+            NBTTagCompound chunkMeta = cmp.getCompound(CHUNK_META);
+            for (String key : chunkMeta.getKeys()) {
+                NBTTagCompound e = chunkMeta.getCompound(key);
+                meta = loadBlockMeta(meta, deserializeOldLoc(key), e);
+            }
+        } else if (cmp.hasKey(CHUNK_META_LIST)) {
+            NBTTagList chunkMeta = cmp.getList(CHUNK_META_LIST, 10);
+            final int size = chunkMeta.size();
+            for (int i = 0; i < size; i++) {
+                NBTTagCompound e = chunkMeta.getCompound(i);
+                if (e.hasKey(BLOCK_POS)) {
+                    NBTTagCompound blockPos = e.getCompound(BLOCK_POS);
+                    meta = loadBlockMeta(meta, toBlockKey(blockPos), e);
+                }
+            }
+        }
+        chunk.meta = meta;
+    }
+
+    private static ChunkPersistentMeta loadBlockMeta(ChunkPersistentMeta meta, Vector key, NBTTagCompound e) {
+        PersistentMetaMap map = getMetaMapFromCompound(e);
+        if (map != null && !map.isEmpty()) {
+            if (meta == null) {
+                meta = new ChunkPersistentMeta();
+            }
+            meta.put(key, map);
+        }
+        return meta;
+    }
+
+
+
+    /**
+     * Converts an Object into NBT
+     * @param value
+     * @return
+     */
+    private static NBTBase getNbtFromObject(Object value) {
+        if (value == null) {
+            return null;
+        }
+        if (value instanceof String) {
+            return new NBTTagString((String) value);
+        } else if (value instanceof ItemStack || value instanceof org.bukkit.inventory.ItemStack) {
+            ItemStack item;
+            if (value instanceof org.bukkit.inventory.ItemStack) {
+                item = CraftItemStack.asNMSCopy((org.bukkit.inventory.ItemStack) value);
+            } else {
+                item = (ItemStack) value;
+            }
+            if (item == null) {
+                return null;
+            }
+            NBTTagCompound itemnbt = new NBTTagCompound();
+            itemnbt.setString(META_TYPE, ITEM);
+            return item.save(itemnbt);
+        } else if (value instanceof Long) {
+            return new NBTTagLong((Long) value);
+        } else if (value instanceof Integer) {
+            return new NBTTagInt((Integer) value);
+        } else if (value instanceof Double) {
+            return new NBTTagDouble((Double) value);
+        } else if (value instanceof Float) {
+            return new NBTTagFloat((Float) value);
+        } else if (value instanceof PersistentMetaMap) {
+            return getCompoundFromMetaMap((PersistentMetaMap) value);
+        } else if (value instanceof PersistentMetaList) {
+            NBTTagList list = new NBTTagList();
+            for (Object obj : (Iterable<?>) value) {
+                NBTBase add = getNbtFromObject(obj);
+                if (add != null) {
+                    list.add(add);
+                }
+            }
+            return list.isEmpty() ? null : list;
+        }
+
+        return null;
+    }
+
+    /**
+     * Converts NBT into an Object
+     * @param nbt
+     * @return
+     */
+    @SuppressWarnings("RedundantCast")
+    private static Object getObjectFromNbt(NBTBase nbt) {
+        if (nbt == null) {
+            return null;
+        }
+        if (nbt instanceof NBTTagString) {
+            return (String) nbt.getStringValue();
+            // Redundant casts added to each number so that it will fail to compile
+            // If the method names change for each type. Do not remove.
+        } else if (nbt instanceof NBTTagInt) {
+            return (Integer) ((NBTNumber) nbt).e();
+        } else if (nbt instanceof NBTTagLong) {
+            return (Long) ((NBTNumber) nbt).d();
+        } else if (nbt instanceof NBTTagFloat) {
+            return (Float) ((NBTNumber) nbt).i();
+        } else if (nbt instanceof NBTTagDouble) {
+            return (Double) ((NBTNumber) nbt).asDouble();
+        } else if (nbt instanceof NBTTagList) {
+            NBTTagList nbtlist = (NBTTagList) nbt;
+            if (nbtlist.isEmpty()) {
+                return null;
+            }
+            PersistentMetaList<Object> list = PaperMetaAccessor.newList();
+            for (int i = 0; i < nbtlist.size(); i++) {
+                final Object obj = getObjectFromNbt(nbtlist.list.get(i));
+                if (obj != null) {
+                    list.add(obj);
+                }
+            }
+            return list.isEmpty() ? null : list;
+        } else if (nbt instanceof NBTTagCompound) {
+            NBTTagCompound cmp = (NBTTagCompound) nbt.clone();
+            if (cmp.hasKey(META_TYPE)) {
+                String type = cmp.getString(META_TYPE);
+                cmp.remove(META_TYPE);
+                if (ITEM.equals(type)) {
+                    return CraftItemStack.asCraftMirror(ItemStack.a(cmp));
+                } else if (META_MAP.equals(type)) {
+                    final PersistentMetaMap metaMap = getMetaMapFromCompound(cmp);
+                    if (metaMap == null || metaMap.isEmpty()) {
+                        return null;
+                    }
+                    return metaMap;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Converts a NBTTagCompound to a MetaMap
+     * @param cmp
+     * @return
+     */
+    private static PersistentMetaMap getMetaMapFromCompound(NBTTagCompound cmp) {
+        if (cmp.map.isEmpty()) {
+            return null;
+        }
+        PersistentMetaMap map = new PersistentMetaMap();
+        for (Entry<String, NBTBase> entry : cmp.map.entrySet()) {
+            final Object metaData = getObjectFromNbt(entry.getValue());
+            if (metaData != null) {
+                PaperMetaAccessor.setValue(map, new PersistentMetaKey(entry.getKey()), metaData);
+            }
+        }
+        return map;
+    }
+
+    /**
+     * Converts a MetaMap into an NBTTagCompount
+     * @param map
+     * @return
+     */
+    private static NBTTagCompound getCompoundFromMetaMap(PersistentMetaMap map) {
+        NBTTagCompound cmp = new NBTTagCompound();
+        if (map.isEmpty()) {
+            return cmp;
+        }
+        cmp.setString(META_TYPE, META_MAP);
+        for (MetaMap.MetaEntry entry : map.getEntries()) {
+            NBTBase add = getNbtFromObject(entry.getValue());
+            if (add != null) {
+                // TODO: KEY saving
+                cmp.set(entry.getKey().toString(), add);
+            }
+        }
+        return cmp;
+    }
+
+    private static NBTTagCompound serializePos(long key) {
+        NBTTagCompound cmp = new NBTTagCompound();
+        cmp.setInt("x", (int) ((key << 37) >> 37));
+        cmp.setInt("y", (int) (key >>> 54));
+        cmp.setInt("z", (int) ((key << 10) >> 37));
+        return cmp;
+    }
+
+    private static final Pattern COLON_SPLIT = Pattern.compile(":");
+    /**
+     * Parses a string into BlockPos
+     *
+     * @param loc
+     * @return
+     */
+    private static Vector deserializeOldLoc(String loc) {
+        if (loc != null)  {
+            String[] args = COLON_SPLIT.split(loc, 3);
+            if (args.length == 3) {
+                try {
+                    int x = (int) Math.floor(Float.parseFloat(args[0]));
+                    int y = (int) Math.floor(Float.parseFloat(args[1]));
+                    int z = (int) Math.floor(Float.parseFloat(args[2]));
+                    return new Vector(x, y, z);
+                } catch (NumberFormatException ignored) {}
+            }
+        }
+        return null;
+    }
+    private static long toBlockKey(NBTTagCompound pos) {
+        return ((long)pos.getInt("x") & 0x7FFFFFF) | (((long)pos.getInt("z") & 0x7FFFFFF) << 27) | ((long)pos.getInt("y") << 54);
+    }
+    static long toBlockKey(BlockPosition pos) {
+        return ((long)pos.getX() & 0x7FFFFFF) | (((long)pos.getZ() & 0x7FFFFFF) << 27) | ((long)pos.getY() << 54);
+    }
+
+    static void processSetAir(Chunk chunk, BlockPosition pos) {
+        ChunkMetaHolder meta = chunk.meta;
+        if (meta.blockMetaMap == null) {
+            return;
+        }
+        Vector coords = new Vector(pos.getX(), pos.getY(), pos.getZ());
+        if (meta.blockMetaMap.containsKey(coords)) {
+            //new BlockWithPersistentMetaClearedEvent(MCUtil.toLocation(chunk.world, pos).getBlock()).callEvent();
+        }
+    }
+
+    static void filterTileEntityMeta(NBTTagCompound cmp) {
+        cmp.remove(TILEENTITY_META);
+    }
+
+    public static void reload() {
+        // Players are not guaranteed to be in a chunk if dead
+        for (Player entity : Bukkit.getOnlinePlayers()) {
+            ((CraftEntity) entity).getHandle().meta.reload();
+        }
+        for (WorldServer world : MinecraftServer.getServer().worlds) {
+            for (Entity entity : world.entityList) {
+                entity.meta.reload();
+            }
+            for (Chunk chunk : world.getChunkProviderServer().chunks.values()) {
+                chunk.meta.reload();
+            }
+        }
+    }
+    private static PersistentMetaMap createPersistent(long key) {
+        return new PersistentMetaMap();
+    }
+    private static TempMetaMap createTemp(long key) {
+        return new TempMetaMap();
+    }
+
+    public static class MetaHolder implements MetaContainer {
+        TempMetaMap temp;
+
+        @Override
+        public TempMetaMap getTempMetaMap(TempMetaKey key, boolean isWrite) {
+            if (isWrite && temp == null) {
+                synchronized (this) {
+                    if (temp == null) {
+                        temp = new TempMetaMap();
+                    }
+                }
+            }
+            return temp;
+        }
+
+        public void reload() {
+            synchronized (this) {
+                temp = null;
+            }
+        }
+    }
+    public static class PersistentMetaHolder extends MetaHolder implements PersistentMetaContainer {
+        PersistentMetaMap persistent;
+        @Override
+        public PersistentMetaMap getPersistentMetaMap(PersistentMetaKey key, boolean isWrite) {
+            if (isWrite && persistent == null) {
+                synchronized (this) {
+                    if (persistent == null) {
+                        persistent = new PersistentMetaMap();
+                    }
+                }
+            }
+            return persistent;
+        }
+
+        @Override
+        public TempMetaMap getTempMetaMap(TempMetaKey key, boolean isWrite) {
+            return null;
+        }
+    }
+
+    public static class ChunkMetaHolder extends PersistentMetaHolder {
+
+        Long2ObjectMap<PersistentMetaMap> blockMetaMap = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>(0));
+        Long2ObjectMap<TempMetaMap> blockTempMetaMap = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>(0));
+        Long2ObjectMap<PersistentMetaMap> locMetaMap = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>(0));
+        Long2ObjectMap<TempMetaMap> locTempMetaMap = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>(0));
+
+        public PersistentMetaMap getLocationPersistentMetaMap(long blockKey, boolean isBlockMeta, boolean isWrite) {
+            final Long2ObjectMap<PersistentMetaMap> map = isBlockMeta ? blockMetaMap : locMetaMap;
+            if (isWrite) {
+                return map.computeIfAbsent(blockKey, PaperMetaApi::createPersistent);
+            } else {
+                return map.get(blockKey);
+            }
+        }
+
+        public TempMetaMap getLocationTempMetaMap(long blockKey, boolean isBlockMeta, boolean isWrite) {
+            final Long2ObjectMap<TempMetaMap> map = isBlockMeta ? blockTempMetaMap : locTempMetaMap;
+            if (isWrite) {
+                return map.computeIfAbsent(blockKey, PaperMetaApi::createTemp);
+            } else {
+                return map.get(blockKey);
+            }
+        }
+
+        public void reload() {
+            super.reload();
+            blockTempMetaMap.clear();
+            locTempMetaMap.clear();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index d2359a30f8..3443d9858d 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -11,6 +11,7 @@ import org.bukkit.inventory.InventoryHolder; // CraftBukkit
 public abstract class TileEntity implements KeyedObject { // Paper
 
     public Timing tickTimer = MinecraftTimings.getTileEntityTimings(this); // Paper
+    public PaperMetaApi.ChunkMetaHolder meta = new PaperMetaApi.ChunkMetaHolder(); // Paper
     boolean isLoadingStructure = false; // Paper
     private static final Logger a = LogManager.getLogger();
     private final TileEntityTypes<?> e; public TileEntityTypes getTileEntityType() { return e; } // Paper - OBFHELPER
diff --git a/src/main/java/net/minecraft/server/WorldData.java b/src/main/java/net/minecraft/server/WorldData.java
index b0445d6a26..18039b044e 100644
--- a/src/main/java/net/minecraft/server/WorldData.java
+++ b/src/main/java/net/minecraft/server/WorldData.java
@@ -70,6 +70,7 @@ public class WorldData {
     private NBTTagCompound U;
     private final GameRules V;
     public WorldServer world; // CraftBukkit
+    public PaperMetaApi.PersistentMetaHolder meta = new PaperMetaApi.PersistentMetaHolder(); // Paper
 
     protected WorldData() {
         this.f = WorldType.NORMAL;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 3238ca7420..05529b401a 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -3,7 +3,10 @@ package org.bukkit.craftbukkit;
 import java.lang.ref.WeakReference;
 import java.util.Arrays;
 
-import java.util.Random;
+import com.destroystokyo.paper.meta.PersistentMetaKey;
+import com.destroystokyo.paper.meta.PersistentMetaMap;
+import com.destroystokyo.paper.meta.TempMetaKey;
+import com.destroystokyo.paper.meta.TempMetaMap;
 import net.minecraft.server.*;
 
 import org.bukkit.Chunk;
@@ -23,6 +26,28 @@ public class CraftChunk implements Chunk {
     private static final DataPaletteBlock<IBlockData> emptyBlockIDs = new ChunkSection(0, false).getBlocks();
     private static final byte[] emptySkyLight = new byte[2048];
 
+    // Paper start
+    @Override
+    public PersistentMetaMap getLocationPersistentMetaMap(long blockKey, PersistentMetaKey key, boolean isBlockMeta, boolean isWrite) {
+        return getHandle().chunkMeta.getLocationPersistentMetaMap(blockKey, isBlockMeta, isWrite);
+    }
+
+    @Override
+    public TempMetaMap getLocationTempMetaMap(long blockKey, TempMetaKey key, boolean isBlockMeta, boolean isWrite) {
+        return getHandle().chunkMeta.getLocationTempMetaMap(blockKey, isBlockMeta, isWrite);
+    }
+
+    @Override
+    public PersistentMetaMap getPersistentMetaMap(PersistentMetaKey key, boolean isWrite) {
+        return getHandle().chunkMeta.getPersistentMetaMap(key, isWrite);
+    }
+
+    @Override
+    public TempMetaMap getTempMetaMap(TempMetaKey key, boolean isWrite) {
+        return getHandle().chunkMeta.getTempMetaMap(key, isWrite);
+    }
+    // Paper end
+
     public CraftChunk(net.minecraft.server.Chunk chunk) {
         this.weakChunk = new WeakReference<net.minecraft.server.Chunk>(chunk);
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 0552659354..77cfb437a6 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -843,6 +843,7 @@ public final class CraftServer implements Server {
                 "This plugin is not properly shutting down its async tasks when it is being reloaded.  This may cause conflicts with the newly loaded version of the plugin"
             ));
         }
+        net.minecraft.server.PaperMetaApi.reload();
         loadPlugins();
         enablePlugins(PluginLoadOrder.STARTUP);
         enablePlugins(PluginLoadOrder.POSTWORLD);
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
index dd7b3d766f..b159f80f40 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
@@ -30,6 +30,14 @@ import org.bukkit.craftbukkit.util.CraftLegacy;
 
 public class CraftInventory implements Inventory {
     protected final IInventory inventory;
+    // Paper start
+    public net.minecraft.server.PaperMetaApi.MetaHolder meta = new net.minecraft.server.PaperMetaApi.MetaHolder();
+
+    @Override
+    public com.destroystokyo.paper.meta.TempMetaMap getTempMetaMap(com.destroystokyo.paper.meta.TempMetaKey key, boolean isWrite) {
+        return meta.getTempMetaMap(key, isWrite);
+    }
+    // Paper end
 
     public CraftInventory(IInventory inventory) {
         this.inventory = inventory;
-- 
2.18.0

