From 06ba67d3f8b96a68e0d0cf9898781aa68546694f Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sat, 11 Aug 2018 15:07:54 -0400
Subject: [PATCH] Persistent and Temporary Meta API

Allows plugins to store metadata on many objects. Persistent data will
be saved with the object and survives restarts.

Temporary Metadata is a replacement API for Bukkit's Metadatable interface,
that provides an API that doesn't suck, and is simpler (ultimately just a hashmap)

diff --git a/src/main/java/com/destroystokyo/paper/meta/BothMetaContainer.java b/src/main/java/com/destroystokyo/paper/meta/BothMetaContainer.java
new file mode 100644
index 000000000..61b710893
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/BothMetaContainer.java
@@ -0,0 +1,15 @@
+package com.destroystokyo.paper.meta;
+
+public interface BothMetaContainer extends PersistentMetaContainer, TemporaryMetaContainer {
+
+    @Override
+    default MetaMap getMetaMap(MetaKey key, boolean isWrite) {
+        if (key instanceof TempMetaKey) {
+            return getMetaMap((TempMetaKey) key, isWrite);
+        } else if (key instanceof PersistentMetaKey) {
+            return getMetaMap((PersistentMetaKey) key, isWrite);
+        } else {
+            throw new IllegalArgumentException("Unknown Key Type");
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/meta/Meta.java b/src/main/java/com/destroystokyo/paper/meta/Meta.java
new file mode 100644
index 000000000..9536ed24f
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/Meta.java
@@ -0,0 +1,42 @@
+package com.destroystokyo.paper.meta;
+
+import org.bukkit.NamespacedKey;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.plugin.Plugin;
+
+@SuppressWarnings("WeakerAccess")
+public class Meta {
+
+    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
+    public static boolean isValidPersistentMeta(Object value) {
+        return (value instanceof String) || (value instanceof Long) ||
+            (value instanceof Integer) || (value instanceof ItemStack) ||
+            (value instanceof Float) || (value instanceof Double) ||
+            (value instanceof PersistentMetaMap) || (value instanceof PersistentMetaList);
+        // TODO: ConfigurationSerializable
+    }
+
+    public static TempMetaKey createTempKey(String key) {
+        return new TempMetaKey(null, key);
+    }
+
+    public static PersistentMetaKey createPersistentKey(String key) {
+        return new PersistentMetaKey(null, key);
+    }
+
+    public static TempMetaKey createTempKey(Plugin plugin, String key) {
+        return new TempMetaKey(plugin.getName(), key);
+    }
+
+    public static PersistentMetaKey createPersistentKey(Plugin plugin, String key) {
+        return new PersistentMetaKey(plugin.getName(), key);
+    }
+
+    public static TempMetaKey createTempKey(NamespacedKey key) {
+        return new TempMetaKey(key.getNamespace(), key.getKey());
+    }
+
+    public static PersistentMetaKey createPersistentKey(NamespacedKey key) {
+        return new PersistentMetaKey(key.getNamespace(), key.getKey());
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/meta/MetaContainer.java b/src/main/java/com/destroystokyo/paper/meta/MetaContainer.java
new file mode 100644
index 000000000..d0c30692a
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/MetaContainer.java
@@ -0,0 +1,151 @@
+package com.destroystokyo.paper.meta;
+
+import org.bukkit.inventory.ItemStack;
+
+/**
+ * Represents an object that can contain metadata.
+ * <p>
+ * This is abstract from the Persistent vs temporary context
+ * <p>
+ * This API is not thread safe!
+ */
+@SuppressWarnings("unchecked")
+public interface MetaContainer {
+
+    MetaMap getMetaMap(MetaKey key, boolean isWrite);
+
+
+    default boolean hasMeta(MetaKey key) {
+        final MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null && !metaMap.isEmpty() && metaMap.containsKey(key);
+    }
+
+    default <T> T removeMeta(MetaKey key) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? (T) metaMap.remove(key) : null;
+    }
+
+    default Integer getIntegerMeta(MetaKey key) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? metaMap.getInteger(key, null) : null;
+    }
+
+    default Integer getIntegerMeta(MetaKey key, Integer def) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? metaMap.getInteger(key, def) : null;
+    }
+
+    default Integer setIntegerMeta(MetaKey key, Integer value) {
+        MetaMap metaMap = getMetaMap(key, true);
+        return metaMap != null ? metaMap.setInteger(key, value) : null;
+    }
+
+    default Long getLongMeta(MetaKey key) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? metaMap.getLong(key, null) : null;
+    }
+
+    default Long getLongMeta(MetaKey key, Long def) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? metaMap.getLong(key, def) : null;
+    }
+
+    default Long setLongMeta(MetaKey key, Long value) {
+        MetaMap metaMap = getMetaMap(key, true);
+        return metaMap != null ? metaMap.setLong(key, value) : null;
+    }
+
+    default Double getDoubleMeta(MetaKey key) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? metaMap.getDouble(key, null) : null;
+    }
+
+    default Double getDoubleMeta(MetaKey key, Double def) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? metaMap.getDouble(key, def) : null;
+    }
+
+    default Double setDoubleMeta(MetaKey key, Double value) {
+        MetaMap metaMap = getMetaMap(key, true);
+        return metaMap != null ? metaMap.setDouble(key, value) : null;
+    }
+
+    default Float getFloatMeta(MetaKey key) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? metaMap.getFloat(key, null) : null;
+    }
+
+    default Float getFloatMeta(MetaKey key, Float def) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? metaMap.getFloat(key, def) : null;
+    }
+
+    default Float setFloatMeta(MetaKey key, Float value) {
+        MetaMap metaMap = getMetaMap(key, true);
+        return metaMap != null ? metaMap.setFloat(key, value) : null;
+    }
+
+    default Boolean getBooleanMeta(MetaKey key) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? metaMap.getBoolean(key, null) : null;
+    }
+
+    default Boolean getBooleanMeta(MetaKey key, Boolean def) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? metaMap.getBoolean(key, def) : null;
+    }
+
+    default Boolean setBooleanMeta(MetaKey key, Boolean value) {
+        MetaMap metaMap = getMetaMap(key, true);
+        return metaMap != null ? metaMap.setBoolean(key, value) : null;
+    }
+
+    default <T extends PersistentMetaMap> T getMapMeta(PersistentMetaKey key) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? (T) metaMap.getMap(key, null) : null;
+    }
+
+    default <T extends PersistentMetaMap> T getMapMeta(PersistentMetaKey key, PersistentMetaMap def) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? (T) metaMap.getMap(key, def) : null;
+    }
+
+    default <T extends PersistentMetaMap> T setMapMeta(PersistentMetaKey key, PersistentMetaMap value) {
+        MetaMap metaMap = getMetaMap(key, true);
+        return metaMap != null ? (T) metaMap.setMap(key, value) : null;
+    }
+
+    default <Z, T extends PersistentMetaList<Z>> T getListMeta(PersistentMetaKey key) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? (T) metaMap.getList(key, null) : null;
+    }
+
+    default <Z, T extends PersistentMetaList<Z>> T getListMeta(PersistentMetaKey key, PersistentMetaList<Z> def) {
+        MetaMap metaMap = getMetaMap(key, false);
+        return metaMap != null ? (T) metaMap.getList(key, def) : null;
+    }
+
+    default <Z, T extends PersistentMetaList<Z>> T setListMeta(PersistentMetaKey key, PersistentMetaList<Z> value) {
+        MetaMap metaMap = getMetaMap(key, true);
+        return metaMap != null ? (T) metaMap.setList(key, value) : null;
+    }
+
+    default <T extends ItemStack> T getItemStackMeta(PersistentMetaKey key) {
+        MetaMap metaMap = getMetaMap(key, true);
+        return metaMap != null ? (T) metaMap.getItemStack(key, null) : null;
+    }
+
+    default <T extends ItemStack> T getItemStackMeta(PersistentMetaKey key, ItemStack def) {
+        MetaMap metaMap = getMetaMap(key, true);
+        return metaMap != null ? (T) metaMap.getItemStack(key, def) : null;
+    }
+
+    default <T extends ItemStack> T setItemStackMeta(PersistentMetaKey key, ItemStack value) {
+        MetaMap metaMap = getMetaMap(key, true);
+        return metaMap != null ? (T) metaMap.setItemStack(key, value) : null;
+    }
+
+
+    // TODO: ConfigurationSerializeable
+    // TODO: increment number methods
+}
diff --git a/src/main/java/com/destroystokyo/paper/meta/MetaKey.java b/src/main/java/com/destroystokyo/paper/meta/MetaKey.java
new file mode 100644
index 000000000..cf1838e7f
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/MetaKey.java
@@ -0,0 +1,75 @@
+package com.destroystokyo.paper.meta;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class MetaKey {
+
+    private static final Map<String, Integer> idMap = new ConcurrentHashMap<>();
+    private static final Map<Integer, MetaKey> idReverseMap = new ConcurrentHashMap<>();
+    private static final AtomicInteger idPool = new AtomicInteger(1);
+    private final String namespace;
+    private final String key;
+    private final String label;
+    private final int id;
+
+    static MetaKey getMetaKey(int id) {
+        return idReverseMap.get(id);
+    }
+
+    MetaKey(@Nullable String namespace, @Nonnull String key) {
+        this.namespace = namespace;
+        this.key = key;
+        this.label = namespace != null ? namespace + ":" + key : key;
+        this.id = idMap.computeIfAbsent(label, (label) -> {
+            int id = idPool.getAndIncrement();
+            idReverseMap.put(id, this);
+            return id;
+        });
+    }
+
+    /**
+     * Namespace to bucket meta under. Can be null for root (Vanilla data)
+     *
+     * @return The key
+     */
+    @Nullable
+    public final String namespace() {
+        return namespace;
+    }
+
+    /**
+     * Key name of where to store meta
+     *
+     * @return The key
+     */
+    @Nonnull
+    public final String key() {
+        return key;
+    }
+
+    final int getId() {
+        return id;
+    }
+
+    @Override
+    public String toString() {
+        return label;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        MetaKey that = (MetaKey) o;
+        return id == that.id;
+    }
+
+    @Override
+    public int hashCode() {
+        return id;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/meta/MetaMap.java b/src/main/java/com/destroystokyo/paper/meta/MetaMap.java
new file mode 100644
index 000000000..b37086b6d
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/MetaMap.java
@@ -0,0 +1,254 @@
+package com.destroystokyo.paper.meta;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import org.bukkit.inventory.ItemStack;
+
+import javax.annotation.Nonnull;
+import java.util.HashSet;
+import java.util.Objects;
+import java.util.Set;
+
+@SuppressWarnings({"unchecked", "WeakerAccess"})
+public abstract class MetaMap<K extends MetaKey> implements Cloneable {
+
+    private final Int2ObjectOpenHashMap<MetaEntry> map = new Int2ObjectOpenHashMap<>(0);
+    private final Int2ObjectOpenHashMap<MetaKey> keys = new Int2ObjectOpenHashMap<>(0);
+
+    MetaMap() {
+
+    }
+
+    MetaMap(MetaMap<K> map) {
+        this.keys.putAll(map.keys);
+        this.map.putAll(map.map);
+    }
+
+    public String getString(@Nonnull K key) {
+        return getString(key, null);
+    }
+
+    public String getString(@Nonnull K key, String def) {
+        String val = getObject0(key);
+        return val != null ? val : def;
+    }
+
+    public String setString(@Nonnull K key, String val) {
+        return putObject0(key, val);
+    }
+
+    public Integer getInteger(@Nonnull K key) {
+        return getInteger(key, null);
+    }
+
+    public Integer getInteger(@Nonnull K key, Integer def) {
+        Number number = getObject0(key);
+        return number != null ? number.intValue() : def;
+    }
+
+    public Integer setInteger(@Nonnull K key, int val) {
+        Number prev = putObject0(key, val);
+        return prev != null ? prev.intValue() : null;
+    }
+
+    public Long getLong(@Nonnull K key) {
+        return getLong(key, null);
+    }
+
+    public Long getLong(@Nonnull K key, Long def) {
+        Number number = getObject0(key);
+        return number != null ? number.longValue() : def;
+    }
+
+    public Long setLong(@Nonnull K key, Long val) {
+        Number prev = putObject0(key, val);
+        return prev != null ? prev.longValue() : null;
+    }
+
+    public Double getDouble(@Nonnull K key) {
+        return getDouble(key, null);
+    }
+
+    public Double getDouble(@Nonnull K key, Double def) {
+        Number number = getObject0(key);
+        return number != null ? number.doubleValue() : def;
+    }
+
+    public Double setDouble(@Nonnull K key, Double val) {
+        Number prev = putObject0(key, val);
+        return prev != null ? prev.doubleValue() : null;
+    }
+
+    public Float getFloat(@Nonnull K key) {
+        return getFloat(key, null);
+    }
+
+    public Float getFloat(@Nonnull K key, Float def) {
+        Number number = getObject0(key);
+        return number != null ? number.floatValue() : def;
+    }
+
+    public Float setFloat(@Nonnull K key, Float val) {
+        Number prev = putObject0(key, val);
+        return prev != null ? prev.floatValue() : null;
+    }
+
+    public Short getShort(@Nonnull K key) {
+        return getShort(key, null);
+    }
+
+    public Short getShort(@Nonnull K key, Short def) {
+        Number number = getObject0(key);
+        return number != null ? number.shortValue() : def;
+    }
+
+    public Short setShort(@Nonnull K key, Short val) {
+        Number prev = putObject0(key, val);
+        return prev != null ? prev.shortValue() : null;
+    }
+
+    public Boolean getBoolean(@Nonnull K key) {
+        return getBoolean(key, null);
+    }
+
+    public Boolean getBoolean(@Nonnull K key, Boolean def) {
+        Number number = getObject0(key);
+        return number != null ? number.intValue() != 0 : def;
+    }
+
+    public Boolean setBoolean(@Nonnull K key, boolean val) {
+        Number prev = putObject0(key, val ? 1 : 0);
+        return prev != null ? prev.intValue() != 0 : null;
+    }
+
+
+    public <T extends PersistentMetaMap> T setMap(@Nonnull K key, PersistentMetaMap value) {
+        return (T) putObject0(key, value);
+    }
+
+    public <T extends PersistentMetaMap> T getMap(@Nonnull K key) {
+        return (T) getObject0(key, null);
+    }
+
+    public <T extends PersistentMetaMap> T getMap(@Nonnull K key, PersistentMetaMap def) {
+        return (T) getObject0(key, def);
+    }
+
+    public <Z, T extends PersistentMetaList<Z>> T setList(@Nonnull K key, PersistentMetaList<Z> value) {
+        return (T) putObject0(key, value);
+    }
+
+    public <Z, T extends PersistentMetaList<Z>> T getList(@Nonnull K key) {
+        return (T) getObject0(key, null);
+    }
+
+    public <Z, T extends PersistentMetaList<Z>> T getList(@Nonnull K key, PersistentMetaList<Z> def) {
+        return (T) getObject0(key, def);
+    }
+
+    public <T extends ItemStack> T setItemStack(@Nonnull K key, ItemStack value) {
+        return (T) putObject0(key, value);
+    }
+
+    public <T extends ItemStack> T getItemStack(@Nonnull K key) {
+        return (T) getObject0(key, null);
+    }
+
+    public <T extends ItemStack> T getItemStack(@Nonnull K key, ItemStack def) {
+        return (T) getObject0(key, def);
+    }
+
+    // TODO: increment number methods
+    // TODO: ConfigurationSerializeable
+
+    public Set<MetaKey> getKeys() {
+        return new HashSet<>(keys.values());
+    }
+
+    /**
+     * For saving
+     */
+    public Set<MetaEntry> getEntries() {
+        return new HashSet<>(map.values());
+    }
+
+
+    public boolean containsKey(K key) {
+        return map.containsKey(key.getId());
+    }
+
+    public boolean isEmpty() {
+        return map.isEmpty();
+    }
+
+    public int size() {
+        return map.size();
+    }
+
+    public <T> T remove(K k) {
+        //noinspection unchecked
+        keys.remove(k.getId());
+        return (T) map.remove(k.getId());
+    }
+
+    public void clear() {
+        keys.clear();
+        map.clear();
+    }
+
+    // Raw access to map is package private so we can control scope access in persistent
+
+    <T> T getObject0(K key) {
+        if (map.isEmpty()) {
+            return null;
+        }
+        //noinspection unchecked
+        return (T) map.get(key.getId());
+    }
+
+    <T> T getObject0(K key, T def) {
+        if (map.isEmpty()) {
+            return def;
+        }
+        //noinspection unchecked
+        MetaEntry metaEntry = map.get(key.getId());
+        return metaEntry != null ? (T) metaEntry.value : def;
+    }
+
+    <T> T putObject0(K key, T value) {
+        keys.put(key.getId(), key);
+        //noinspection unchecked
+        MetaEntry prev = map.put(key.getId(), new MetaEntry(key, value));
+        return prev != null ? (T) prev.value : null;
+    }
+
+    public static class MetaEntry {
+        private MetaKey key;
+        private Object value;
+
+        public MetaEntry(MetaKey key, Object value) {
+            this.key = key;
+            this.value = value;
+        }
+
+        public MetaKey getKey() {
+            return key;
+        }
+
+        public Object getValue() {
+            return value;
+        }
+
+        @Override
+        public int hashCode() {
+            return key.hashCode();
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            MetaEntry metaEntry = (MetaEntry) o;
+            return key.getId() == metaEntry.key.getId() && Objects.equals(value, metaEntry.value);
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/meta/PersistentMetaContainer.java b/src/main/java/com/destroystokyo/paper/meta/PersistentMetaContainer.java
new file mode 100644
index 000000000..7b1ae6da7
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/PersistentMetaContainer.java
@@ -0,0 +1,24 @@
+package com.destroystokyo.paper.meta;
+
+/**
+ * Represents an object that has the capability of storing metadata and
+ * able to persist it between object reloads such as server restarts or chunk reloads.
+ * <p>
+ * Limited to data formats that can be serialized.
+ * <p>
+ * Use the Bukkit {@link org.bukkit.configuration.serialization.ConfigurationSerializable} API to make
+ * your custom data objects safe for persistence.
+ * <p>
+ * This data will not be removed if your plugin is removed. You must handle clean up on your own.
+ * <p>
+ * This API is not thread safe!
+ */
+public interface PersistentMetaContainer extends MetaContainer {
+
+    @Override
+    default MetaMap getMetaMap(MetaKey key, boolean isWrite) {
+        return getMetaMap((PersistentMetaKey) key, isWrite);
+    }
+
+    PersistentMetaMap getMetaMap(PersistentMetaKey key, boolean isWrite);
+}
diff --git a/src/main/java/com/destroystokyo/paper/meta/PersistentMetaKey.java b/src/main/java/com/destroystokyo/paper/meta/PersistentMetaKey.java
new file mode 100644
index 000000000..7693fda9e
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/PersistentMetaKey.java
@@ -0,0 +1,11 @@
+package com.destroystokyo.paper.meta;
+
+public class PersistentMetaKey extends MetaKey {
+    PersistentMetaKey(String namespace, String key) {
+        super(namespace, key);
+    }
+
+    public PersistentMetaKey append(String suffix) {
+        return new PersistentMetaKey(namespace(), key() + suffix);
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/meta/PersistentMetaList.java b/src/main/java/com/destroystokyo/paper/meta/PersistentMetaList.java
new file mode 100644
index 000000000..fd51ace05
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/PersistentMetaList.java
@@ -0,0 +1,61 @@
+package com.destroystokyo.paper.meta;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+public class PersistentMetaList<T> {
+    private final List<T> list = new ArrayList<>();
+
+    public PersistentMetaList() {
+    }
+
+    public PersistentMetaList(List<T> copy) {
+        list.addAll(copy);
+    }
+
+    public boolean add(T o) {
+        if (!Meta.isValidPersistentMeta(o)) {
+            throw new IllegalArgumentException();
+        }
+        return list.add(o);
+    }
+
+    public boolean addAll(Collection<? extends T> c) {
+        for (T t : c) {
+            if (!Meta.isValidPersistentMeta(t)) {
+                throw new IllegalArgumentException();
+            }
+        }
+
+        return list.addAll(c);
+    }
+
+    public boolean addAll(int index, Collection<? extends T> c) {
+        for (T t : c) {
+            if (!Meta.isValidPersistentMeta(t)) {
+                throw new IllegalArgumentException();
+            }
+        }
+
+        return list.addAll(index, c);
+    }
+
+    public T set(int index, T element) {
+        if (!Meta.isValidPersistentMeta(element)) {
+            throw new IllegalArgumentException();
+        }
+        return list.set(index, element);
+    }
+
+    public void add(int index, T element) {
+        if (!Meta.isValidPersistentMeta(element)) {
+            throw new IllegalArgumentException();
+        }
+        list.add(index, element);
+    }
+
+    public PersistentMetaList<T> clone() {
+        return new PersistentMetaList<>(list);
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/meta/PersistentMetaMap.java b/src/main/java/com/destroystokyo/paper/meta/PersistentMetaMap.java
new file mode 100644
index 000000000..ba76986d0
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/PersistentMetaMap.java
@@ -0,0 +1,23 @@
+package com.destroystokyo.paper.meta;
+
+/**
+ * A type protected hashmap for storing meta values
+ * <p>
+ * This API is not thread safe!
+ */
+@SuppressWarnings({"PublicInnerClass", "unchecked", "WeakerAccess"})
+public class PersistentMetaMap extends MetaMap<PersistentMetaKey> {
+
+
+    public PersistentMetaMap() {
+    }
+
+    public PersistentMetaMap(PersistentMetaMap map) {
+        super(map);
+    }
+
+    @SuppressWarnings("MethodDoesntCallSuperMethod")
+    public PersistentMetaMap clone() {
+        return new PersistentMetaMap(this);
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/meta/TempMetaKey.java b/src/main/java/com/destroystokyo/paper/meta/TempMetaKey.java
new file mode 100644
index 000000000..36e5f1e62
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/TempMetaKey.java
@@ -0,0 +1,11 @@
+package com.destroystokyo.paper.meta;
+
+public class TempMetaKey extends MetaKey {
+    TempMetaKey(String namespace, String key) {
+        super(namespace, key);
+    }
+
+    public TempMetaKey append(String suffix) {
+        return new TempMetaKey(namespace(), key() + suffix);
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/meta/TempMetaMap.java b/src/main/java/com/destroystokyo/paper/meta/TempMetaMap.java
new file mode 100644
index 000000000..d223e62d8
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/TempMetaMap.java
@@ -0,0 +1,32 @@
+package com.destroystokyo.paper.meta;
+
+import javax.annotation.Nonnull;
+
+@SuppressWarnings("WeakerAccess")
+public class TempMetaMap extends MetaMap<TempMetaKey> {
+
+    public TempMetaMap() {
+    }
+
+    public TempMetaMap(TempMetaMap map) {
+        super(map);
+    }
+
+    public <T> T getValue(@Nonnull TempMetaKey key) {
+        return getObject0(key);
+    }
+
+    public <T> T getValue(@Nonnull TempMetaKey key, T def) {
+        return getObject0(key, def);
+    }
+
+    public <T> T setValue(@Nonnull TempMetaKey key, T value) {
+        return putObject0(key, value);
+    }
+
+    @SuppressWarnings("MethodDoesntCallSuperMethod")
+    @Override
+    public TempMetaMap clone() {
+        return new TempMetaMap(this);
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/meta/TemporaryMetaContainer.java b/src/main/java/com/destroystokyo/paper/meta/TemporaryMetaContainer.java
new file mode 100644
index 000000000..b3de979e0
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/meta/TemporaryMetaContainer.java
@@ -0,0 +1,40 @@
+package com.destroystokyo.paper.meta;
+
+/**
+ * Represents an object that can store temporary metadata. This data
+ * can survive the lifetime of the object in the servers memory, but will not persist.
+ * <p>
+ * For example, An Entity that is unloaded from the world would lose its temporary metadata,
+ * or when the server restarts.
+ * <p>
+ * This is ultimately a simple hashmap that is bound to the object in question, so
+ * that it will clean itself up on object removal.
+ * <p>
+ * This API is not thread safe!
+ */
+public interface TemporaryMetaContainer extends MetaContainer {
+
+    @Override
+    default MetaMap getMetaMap(MetaKey key, boolean isWrite) {
+        return getMetaMap((TempMetaKey) key, isWrite);
+    }
+
+    TempMetaMap getMetaMap(TempMetaKey key, boolean isWrite);
+
+    default <T> T getMeta(TempMetaKey key) {
+        final MetaMap metaMap = getMetaMap(key, false);
+        //noinspection unchecked
+        return metaMap != null ? (T) metaMap.getObject0(key, null) : null;
+    }
+
+    default <T> T getMeta(TempMetaKey key, T def) {
+        final MetaMap metaMap = getMetaMap(key, false);
+        //noinspection unchecked
+        return metaMap != null ? (T) metaMap.getObject0(key, def) : null;
+    }
+
+    default <T> T setMeta(TempMetaKey key, T val) {
+        TempMetaMap metaMap = getMetaMap(key, true);
+        return metaMap != null ? metaMap.setValue(key, val) : null;
+    }
+}
diff --git a/src/main/java/org/bukkit/entity/Entity.java b/src/main/java/org/bukkit/entity/Entity.java
index 573a69184..570cc4fa0 100644
--- a/src/main/java/org/bukkit/entity/Entity.java
+++ b/src/main/java/org/bukkit/entity/Entity.java
@@ -20,7 +20,7 @@ import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 /**
  * Represents a base entity in the world
  */
-public interface Entity extends Metadatable, CommandSender, Nameable {
+public interface Entity extends Metadatable, CommandSender, Nameable, com.destroystokyo.paper.meta.BothMetaContainer { // Paper
 
     /**
      * Gets the entity's current position
diff --git a/src/main/java/org/bukkit/metadata/Metadatable.java b/src/main/java/org/bukkit/metadata/Metadatable.java
index b47cf2b00..0fb0c3962 100644
--- a/src/main/java/org/bukkit/metadata/Metadatable.java
+++ b/src/main/java/org/bukkit/metadata/Metadatable.java
@@ -7,7 +7,9 @@ import java.util.List;
 /**
  * This interface is implemented by all objects that can provide metadata
  * about themselves.
+ * @deprecated This API has many flaws. Use Papers Meta API. {@link com.destroystokyo.paper.meta.Meta}
  */
+@Deprecated
 public interface Metadatable {
     /**
      * Sets a metadata value in the implementing object's metadata store.
-- 
2.18.0

